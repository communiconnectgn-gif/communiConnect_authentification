const io = require('socket.io-client');

// Configuration
const BASE_URL = 'http://localhost:5000';
const TEST_USER_1 = {
  email: 'test1@guinee.gn',
  password: 'password123'
};
const TEST_USER_2 = {
  email: 'test2@guinee.gn',
  password: 'password123'
};

let user1Token = null;
let user2Token = null;
let user1Socket = null;
let user2Socket = null;
let conversationId = null;

// Fonction utilitaire pour faire des requ√™tes HTTP
function makeRequest(options, data = null) {
  return new Promise((resolve, reject) => {
    const http = require('http');
    const req = http.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const parsed = JSON.parse(responseData);
          resolve({ status: res.statusCode, data: parsed });
        } catch (e) {
          resolve({ status: res.statusCode, data: responseData });
        }
      });
    });

    req.on('error', (e) => {
      reject(e);
    });

    if (data) {
      req.write(JSON.stringify(data));
    }
    
    req.end();
  });
}

// Test 1: Connexion des utilisateurs et obtention des tokens
async function loginUsers() {
  console.log('\nüîê Test 1: Connexion des utilisateurs');
  
  try {
    // Connexion utilisateur 1
    const login1Response = await makeRequest({
      hostname: 'localhost',
      port: 5000,
      path: '/api/auth/login',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    }, TEST_USER_1);

    if (login1Response.status === 200 && login1Response.data.success) {
      user1Token = login1Response.data.token;
      console.log('‚úÖ Utilisateur 1 connect√©');
    } else {
      console.log('‚ùå √âchec connexion utilisateur 1:', login1Response.data.message);
      return false;
    }

    // Connexion utilisateur 2
    const login2Response = await makeRequest({
      hostname: 'localhost',
      port: 5000,
      path: '/api/auth/login',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    }, TEST_USER_2);

    if (login2Response.status === 200 && login2Response.data.success) {
      user2Token = login2Response.data.token;
      console.log('‚úÖ Utilisateur 2 connect√©');
    } else {
      console.log('‚ùå √âchec connexion utilisateur 2:', login2Response.data.message);
      return false;
    }

    return true;
  } catch (error) {
    console.error('‚ùå Erreur lors de la connexion:', error.message);
    return false;
  }
}

// Test 2: Cr√©er une conversation
async function createConversation() {
  console.log('\nüí¨ Test 2: Cr√©ation d\'une conversation');
  
  try {
    const response = await makeRequest({
      hostname: 'localhost',
      port: 5000,
      path: '/api/messages/conversation/create',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${user1Token}`
      }
    }, {
      type: 'private',
      participants: [TEST_USER_2.id || 'test-user-2-id']
    });

    if (response.status === 200 && response.data.success) {
      conversationId = response.data.conversation.conversationId;
      console.log('‚úÖ Conversation cr√©√©e:', conversationId);
      return true;
    } else {
      console.log('‚ùå √âchec cr√©ation conversation:', response.data.message);
      return false;
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de conversation:', error.message);
    return false;
  }
}

// Test 3: Connexion Socket.IO des utilisateurs
async function connectSockets() {
  console.log('\nüîå Test 3: Connexion Socket.IO');
  
  return new Promise((resolve) => {
    let connectedUsers = 0;
    
    // Connexion utilisateur 1
    user1Socket = io(BASE_URL, {
      auth: {
        token: user1Token
      }
    });

    user1Socket.on('connect', () => {
      console.log('‚úÖ Utilisateur 1 connect√© via Socket.IO');
      connectedUsers++;
      
      if (connectedUsers === 2) {
        resolve(true);
      }
    });

    user1Socket.on('connect_error', (error) => {
      console.error('‚ùå Erreur connexion Socket.IO utilisateur 1:', error.message);
      resolve(false);
    });

    // Connexion utilisateur 2
    user2Socket = io(BASE_URL, {
      auth: {
        token: user2Token
      }
    });

    user2Socket.on('connect', () => {
      console.log('‚úÖ Utilisateur 2 connect√© via Socket.IO');
      connectedUsers++;
      
      if (connectedUsers === 2) {
        resolve(true);
      }
    });

    user2Socket.on('connect_error', (error) => {
      console.error('‚ùå Erreur connexion Socket.IO utilisateur 2:', error.message);
      resolve(false);
    });
  });
}

// Test 4: Rejoindre la conversation
async function joinConversation() {
  console.log('\nüë• Test 4: Jointure de la conversation');
  
  return new Promise((resolve) => {
    let joinedUsers = 0;
    
    // Utilisateur 1 rejoint la conversation
    user1Socket.emit('join_conversation', { conversationId });
    
    user1Socket.on('user_joined_conversation', (data) => {
      console.log('‚úÖ Utilisateur 1 a rejoint la conversation');
      joinedUsers++;
      
      if (joinedUsers === 2) {
        resolve(true);
      }
    });

    // Utilisateur 2 rejoint la conversation
    user2Socket.emit('join_conversation', { conversationId });
    
    user2Socket.on('user_joined_conversation', (data) => {
      console.log('‚úÖ Utilisateur 2 a rejoint la conversation');
      joinedUsers++;
      
      if (joinedUsers === 2) {
        resolve(true);
      }
    });

    // Timeout pour √©viter l'attente infinie
    setTimeout(() => {
      if (joinedUsers < 2) {
        console.log('‚ö†Ô∏è Timeout lors de la jointure de conversation');
        resolve(false);
      }
    }, 5000);
  });
}

// Test 5: Envoi de message en temps r√©el
async function testRealTimeMessage() {
  console.log('\nüì§ Test 5: Message en temps r√©el');
  
  return new Promise((resolve) => {
    let messageReceived = false;
    
    // √âcouter les nouveaux messages c√¥t√© utilisateur 2
    user2Socket.on('new_message', (data) => {
      console.log('‚úÖ Message re√ßu en temps r√©el:', data.message.content);
      messageReceived = true;
      resolve(true);
    });

    // Envoyer un message via l'API (qui d√©clenchera Socket.IO)
    makeRequest({
      hostname: 'localhost',
      port: 5000,
      path: '/api/messages/send',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${user1Token}`
      }
    }, {
      conversationId: conversationId,
      content: 'Test de message en temps r√©el ! üöÄ'
    }).then(response => {
      if (response.status === 200 && response.data.success) {
        console.log('‚úÖ Message envoy√© via API');
      } else {
        console.log('‚ùå √âchec envoi message:', response.data.message);
        resolve(false);
      }
    }).catch(error => {
      console.error('‚ùå Erreur lors de l\'envoi:', error.message);
      resolve(false);
    });

    // Timeout pour √©viter l'attente infinie
    setTimeout(() => {
      if (!messageReceived) {
        console.log('‚ö†Ô∏è Timeout - Message non re√ßu en temps r√©el');
        resolve(false);
      }
    }, 10000);
  });
}

// Test 6: Indicateur de frappe
async function testTypingIndicator() {
  console.log('\n‚å®Ô∏è Test 6: Indicateur de frappe');
  
  return new Promise((resolve) => {
    let typingReceived = false;
    let stopTypingReceived = false;
    
    // √âcouter les indicateurs de frappe c√¥t√© utilisateur 2
    user2Socket.on('user_typing', (data) => {
      console.log('‚úÖ Indicateur de frappe re√ßu:', data);
      typingReceived = true;
    });

    user2Socket.on('user_stop_typing', (data) => {
      console.log('‚úÖ Arr√™t de frappe re√ßu:', data);
      stopTypingReceived = true;
      
      if (typingReceived && stopTypingReceived) {
        resolve(true);
      }
    });

    // Envoyer un indicateur de frappe
    user1Socket.emit('typing', { conversationId });
    
    // Arr√™ter l'indicateur apr√®s 2 secondes
    setTimeout(() => {
      user1Socket.emit('stop_typing', { conversationId });
    }, 2000);

    // Timeout pour √©viter l'attente infinie
    setTimeout(() => {
      if (!typingReceived || !stopTypingReceived) {
        console.log('‚ö†Ô∏è Timeout - Indicateurs de frappe non re√ßus');
        resolve(false);
      }
    }, 10000);
  });
}

// Test 7: Statut de lecture
async function testMessageRead() {
  console.log('\nüëÅÔ∏è Test 7: Statut de lecture');
  
  return new Promise((resolve) => {
    let readStatusReceived = false;
    
    // √âcouter les statuts de lecture c√¥t√© utilisateur 1
    user1Socket.on('message_read_by', (data) => {
      console.log('‚úÖ Statut de lecture re√ßu:', data);
      readStatusReceived = true;
      resolve(true);
    });

    // Marquer un message comme lu (simulation)
    user2Socket.emit('message_read', { 
      messageId: 'test-message-id', 
      conversationId 
    });

    // Timeout pour √©viter l'attente infinie
    setTimeout(() => {
      if (!readStatusReceived) {
        console.log('‚ö†Ô∏è Timeout - Statut de lecture non re√ßu');
        resolve(false);
      }
    }, 5000);
  });
}

// Nettoyer les connexions
function cleanup() {
  console.log('\nüßπ Nettoyage des connexions');
  
  if (user1Socket) {
    user1Socket.disconnect();
  }
  
  if (user2Socket) {
    user2Socket.disconnect();
  }
  
  console.log('‚úÖ Connexions ferm√©es');
}

// Fonction principale de test
async function runRealTimeTests() {
  console.log('üß™ Test du syst√®me de messagerie en temps r√©el CommuniConnect\n');
  
  const tests = [
    { name: 'Connexion utilisateurs', fn: loginUsers },
    { name: 'Cr√©ation conversation', fn: createConversation },
    { name: 'Connexion Socket.IO', fn: connectSockets },
    { name: 'Jointure conversation', fn: joinConversation },
    { name: 'Message temps r√©el', fn: testRealTimeMessage },
    { name: 'Indicateur de frappe', fn: testTypingIndicator },
    { name: 'Statut de lecture', fn: testMessageRead }
  ];

  let passedTests = 0;
  let totalTests = tests.length;

  try {
    for (const test of tests) {
      console.log(`\n--- ${test.name} ---`);
      const result = await test.fn();
      if (result) {
        passedTests++;
        console.log(`‚úÖ ${test.name} r√©ussi`);
      } else {
        console.log(`‚ùå ${test.name} √©chou√©`);
      }
      
      // Pause entre les tests
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  } catch (error) {
    console.error('‚ùå Erreur lors des tests:', error.message);
  } finally {
    cleanup();
  }

  console.log('\nüìä R√©sultats des tests temps r√©el:');
  console.log(`‚úÖ Tests r√©ussis: ${passedTests}/${totalTests}`);
  console.log(`‚ùå Tests √©chou√©s: ${totalTests - passedTests}/${totalTests}`);
  
  if (passedTests === totalTests) {
    console.log('\nüéâ Tous les tests temps r√©el sont pass√©s ! Le syst√®me de messagerie en temps r√©el fonctionne parfaitement.');
  } else {
    console.log('\n‚ö†Ô∏è Certains tests temps r√©el ont √©chou√©. V√©rifiez la configuration Socket.IO.');
  }
}

// Ex√©cuter les tests
runRealTimeTests().catch(console.error); 