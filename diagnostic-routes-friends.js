const axios = require('axios');
const fs = require('fs');
const path = require('path');

console.log('üîç DIAGNOSTIC - ROUTES FRIENDS');
console.log('=' .repeat(50));

// Configuration
const API_BASE_URL = 'http://localhost:5000';

// Fonction pour v√©rifier si le serveur est d√©marr√©
async function checkServerStatus() {
  console.log('\n1Ô∏è‚É£ V√©rification du serveur backend...');
  
  try {
    const response = await axios.get(`${API_BASE_URL}/api/health`, {
      timeout: 5000
    });
    
    if (response.data.status === 'OK') {
      console.log('‚úÖ Serveur backend op√©rationnel');
      return true;
    } else {
      console.log('‚ùå Serveur backend non op√©rationnel');
      return false;
    }
  } catch (error) {
    console.log('‚ùå Serveur backend inaccessible:', error.message);
    console.log('üí° Solution: D√©marrer le serveur avec "npm start" dans le dossier server/');
    return false;
  }
}

// Fonction pour tester les routes friends
async function testFriendsRoutes() {
  console.log('\n2Ô∏è‚É£ Test des routes friends...');
  
  const routes = [
    { method: 'GET', path: '/api/friends', name: 'Liste des amis' },
    { method: 'GET', path: '/api/friends/requests', name: 'Demandes re√ßues' },
    { method: 'POST', path: '/api/friends/request', name: 'Envoyer demande' }
  ];
  
  const results = {};
  
  for (const route of routes) {
    try {
      let response;
      
      if (route.method === 'GET') {
        response = await axios.get(`${API_BASE_URL}${route.path}`, {
          timeout: 5000
        });
      } else if (route.method === 'POST') {
        response = await axios.post(`${API_BASE_URL}${route.path}`, {
          recipientId: 'test@example.com'
        }, {
          timeout: 5000
        });
      }
      
      if (response.status === 200 || response.status === 201) {
        console.log(`‚úÖ ${route.name}: ${response.status}`);
        results[route.path] = true;
      } else {
        console.log(`‚ùå ${route.name}: ${response.status}`);
        results[route.path] = false;
      }
    } catch (error) {
      console.log(`‚ùå ${route.name}: ${error.response?.status || error.message}`);
      results[route.path] = false;
    }
  }
  
  return results;
}

// Fonction pour v√©rifier les fichiers de routes
function checkRouteFiles() {
  console.log('\n3Ô∏è‚É£ V√©rification des fichiers de routes...');
  
  const files = [
    'server/routes/friends.js',
    'server/middleware/devAuth.js',
    'server/index.js'
  ];
  
  const results = {};
  
  files.forEach(file => {
    const exists = fs.existsSync(file);
    console.log(`${exists ? '‚úÖ' : '‚ùå'} ${file}`);
    results[file] = exists;
  });
  
  return results;
}

// Fonction pour v√©rifier la configuration dans index.js
function checkIndexConfiguration() {
  console.log('\n4Ô∏è‚É£ V√©rification de la configuration dans index.js...');
  
  const indexPath = 'server/index.js';
  
  if (!fs.existsSync(indexPath)) {
    console.log('‚ùå Fichier server/index.js non trouv√©');
    return false;
  }
  
  const content = fs.readFileSync(indexPath, 'utf8');
  
  // V√©rifier l'import de la route friends
  const hasFriendsImport = content.includes("require('./routes/friends')");
  console.log(`${hasFriendsImport ? '‚úÖ' : '‚ùå'} Import route friends`);
  
  // V√©rifier l'utilisation de la route friends
  const hasFriendsUse = content.includes("app.use('/api/friends'");
  console.log(`${hasFriendsUse ? '‚úÖ' : '‚ùå'} Utilisation route friends`);
  
  return hasFriendsImport && hasFriendsUse;
}

// Fonction pour corriger les probl√®mes
function fixFriendsRoutes() {
  console.log('\n5Ô∏è‚É£ Correction des probl√®mes identifi√©s...');
  
  // V√©rifier et corriger le fichier friends.js
  const friendsPath = 'server/routes/friends.js';
  
  if (!fs.existsSync(friendsPath)) {
    console.log('‚ö†Ô∏è Cr√©ation du fichier friends.js...');
    
    const friendsContent = `const express = require('express');
const { body, validationResult } = require('express-validator');
const devAuth = require('../middleware/devAuth');

const router = express.Router();

// GET /api/friends - R√©cup√©rer la liste des amis
router.get('/', devAuth, async (req, res) => {
  try {
    const friends = [
      {
        _id: 'friend-1',
        firstName: 'Mamadou',
        lastName: 'Diallo',
        email: 'mamadou.diallo@communiconnect.gn',
        status: 'accepted',
        friendshipId: 'friendship-1'
      },
      {
        _id: 'friend-2',
        firstName: 'Fatou',
        lastName: 'Camara',
        email: 'fatou.camara@communiconnect.gn',
        status: 'accepted',
        friendshipId: 'friendship-2'
      }
    ];

    res.json({
      success: true,
      friends
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de la liste d\'amis:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur serveur'
    });
  }
});

// GET /api/friends/requests - R√©cup√©rer les demandes re√ßues
router.get('/requests', devAuth, async (req, res) => {
  try {
    const requests = [
      {
        _id: 'req-1',
        requester: {
          _id: 'user-4',
          firstName: 'Aissatou',
          lastName: 'Bah',
          email: 'aissatou.bah@communiconnect.gn'
        },
        status: 'pending',
        createdAt: new Date()
      }
    ];

    res.json({
      success: true,
      requests
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des demandes d\'amis:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur serveur'
    });
  }
});

// POST /api/friends/request - Envoyer une demande d'ami
router.post('/request', devAuth, [
  body('recipientId').notEmpty().withMessage('ID du destinataire requis')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Donn√©es invalides',
        errors: errors.array()
      });
    }

    const { recipientId } = req.body;
    const requesterId = req.user._id || req.user.id;

    const friendRequest = {
      _id: \`req-\${Date.now()}\`,
      requester: {
        _id: requesterId,
        firstName: req.user.firstName || 'Test',
        lastName: req.user.lastName || 'User'
      },
      recipient: {
        _id: \`user-\${Date.now()}\`,
        firstName: 'Autre',
        lastName: 'Utilisateur',
        email: recipientId
      },
      status: 'pending',
      createdAt: new Date()
    };

    res.status(201).json({
      success: true,
      message: 'Demande d\\'ami envoy√©e avec succ√®s',
      friendRequest
    });
  } catch (error) {
    console.error('Erreur lors de l\\'envoi de la demande d\\'ami:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur serveur'
    });
  }
});

module.exports = router;`;
    
    fs.writeFileSync(friendsPath, friendsContent);
    console.log('‚úÖ Fichier friends.js cr√©√©');
  } else {
    console.log('‚úÖ Fichier friends.js existe d√©j√†');
  }
  
  // V√©rifier et corriger le middleware devAuth
  const devAuthPath = 'server/middleware/devAuth.js';
  
  if (!fs.existsSync(devAuthPath)) {
    console.log('‚ö†Ô∏è Cr√©ation du fichier devAuth.js...');
    
    const devAuthContent = `// Middleware d'authentification pour le mode d√©veloppement
const devAuth = (req, res, next) => {
  // En mode d√©veloppement, permettre l'acc√®s sans authentification
  if (process.env.NODE_ENV === 'development' || !process.env.NODE_ENV) {
    // Cr√©er un utilisateur de test
    req.user = {
      _id: 'test-user-id',
      id: 'test-user-id',
      firstName: 'Test',
      lastName: 'User',
      email: 'test@communiconnect.gn',
      isVerified: true
    };
    return next();
  }
  
  // En production, utiliser l'authentification normale
  const auth = require('./auth');
  return auth(req, res, next);
};

module.exports = devAuth;`;
    
    fs.writeFileSync(devAuthPath, devAuthContent);
    console.log('‚úÖ Fichier devAuth.js cr√©√©');
  } else {
    console.log('‚úÖ Fichier devAuth.js existe d√©j√†');
  }
  
  // V√©rifier et corriger index.js
  const indexPath = 'server/index.js';
  
  if (fs.existsSync(indexPath)) {
    let content = fs.readFileSync(indexPath, 'utf8');
    
    // V√©rifier si la route friends est configur√©e
    if (!content.includes("app.use('/api/friends'")) {
      console.log('‚ö†Ô∏è Ajout de la route friends dans index.js...');
      
      // Trouver la ligne apr√®s les autres routes
      const routesIndex = content.indexOf("app.use('/api/");
      if (routesIndex !== -1) {
        const insertIndex = content.indexOf('\n', routesIndex) + 1;
        const friendsRoute = "app.use('/api/friends', require('./routes/friends'));\n";
        
        content = content.slice(0, insertIndex) + friendsRoute + content.slice(insertIndex);
        fs.writeFileSync(indexPath, content);
        console.log('‚úÖ Route friends ajout√©e dans index.js');
      }
    } else {
      console.log('‚úÖ Route friends d√©j√† configur√©e dans index.js');
    }
  }
}

// Fonction principale
async function runDiagnostic() {
  console.log('üöÄ D√©marrage du diagnostic des routes friends...\n');
  
  const results = {
    server: false,
    routes: {},
    files: {},
    config: false
  };
  
  // Test 1: Serveur
  results.server = await checkServerStatus();
  
  if (!results.server) {
    console.log('\n‚ùå DIAGNOSTIC ARR√äT√â - Serveur non disponible');
    console.log('\nüîß SOLUTIONS:');
    console.log('1. Ouvrir un terminal dans le dossier server/');
    console.log('2. Ex√©cuter: npm start');
    console.log('3. Attendre que le serveur d√©marre (port 5000)');
    return;
  }
  
  // Test 2: Routes
  results.routes = await testFriendsRoutes();
  
  // Test 3: Fichiers
  results.files = checkRouteFiles();
  
  // Test 4: Configuration
  results.config = checkIndexConfiguration();
  
  // R√©sultats
  console.log('\n' + '=' .repeat(50));
  console.log('üìä R√âSULTATS DU DIAGNOSTIC');
  console.log('=' .repeat(50));
  
  console.log(`üñ•Ô∏è Serveur: ${results.server ? '‚úÖ' : '‚ùå'}`);
  console.log(`üìÅ Fichiers: ${Object.values(results.files).filter(Boolean).length}/${Object.keys(results.files).length} pr√©sents`);
  console.log(`‚öôÔ∏è Configuration: ${results.config ? '‚úÖ' : '‚ùå'}`);
  
  const routeSuccess = Object.values(results.routes).filter(Boolean).length;
  const routeTotal = Object.keys(results.routes).length;
  console.log(`üîó Routes: ${routeSuccess}/${routeTotal} fonctionnelles`);
  
  // Si des probl√®mes sont d√©tect√©s, proposer des corrections
  if (routeSuccess < routeTotal || !results.config) {
    console.log('\nüîß CORRECTIONS N√âCESSAIRES');
    fixFriendsRoutes();
    
    console.log('\nüéØ PROCHAINES √âTAPES:');
    console.log('1. Red√©marrer le serveur: cd server && npm start');
    console.log('2. Tester √† nouveau: node diagnostic-routes-friends.js');
    console.log('3. V√©rifier l\'interface: http://localhost:3000');
  } else {
    console.log('\n‚úÖ TOUTES LES ROUTES FRIENDS FONCTIONNENT !');
  }
  
  console.log('\nüí° Pour tester l\'interface:');
  console.log('   Ouvrez http://localhost:3000 et allez dans "Mes Amis"');
}

// Ex√©cuter le diagnostic
runDiagnostic().catch(error => {
  console.error('‚ùå Erreur lors du diagnostic:', error.message);
}); 