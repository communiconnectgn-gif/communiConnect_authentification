#!/usr/bin/env node

/**
 * üß™ SCRIPT DE TEST MANUEL UTILISATEUR - COMMUNICONNECT
 * 
 * Ce script permet de tester manuellement toutes les fonctionnalit√©s
 * utilisateur de CommuniConnect de mani√®re interactive.
 */

const axios = require('axios');
const readline = require('readline');

const BASE_URL = 'http://localhost:5000/api';
let authToken = null;
let currentUser = null;

// Interface de ligne de commande
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Couleurs pour l'affichage
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`‚úÖ ${message}`, 'green');
}

function logError(message) {
  log(`‚ùå ${message}`, 'red');
}

function logInfo(message) {
  log(`‚ÑπÔ∏è  ${message}`, 'blue');
}

function logWarning(message) {
  log(`‚ö†Ô∏è  ${message}`, 'yellow');
}

// Fonctions de test
async function testAuthentification() {
  log('\nüîê TEST D\'AUTHENTIFICATION', 'cyan');
  log('============================', 'cyan');
  
  try {
    // Test d'inscription
    logInfo('1. Test d\'inscription...');
    const registerData = {
      username: 'testuser_' + Date.now(),
      email: `test${Date.now()}@communiconnect.com`,
      password: 'password123'
    };
    
    const registerResponse = await axios.post(`${BASE_URL}/auth/register`, registerData);
    logSuccess(`Inscription r√©ussie: ${registerData.username}`);
    
    // Test de connexion
    logInfo('2. Test de connexion...');
    const loginData = {
      email: registerData.email,
      password: registerData.password
    };
    
    const loginResponse = await axios.post(`${BASE_URL}/auth/login`, loginData);
    authToken = loginResponse.data.token;
    currentUser = loginResponse.data.user;
    
    logSuccess(`Connexion r√©ussie: ${currentUser.username}`);
    logInfo(`Token JWT re√ßu: ${authToken.substring(0, 20)}...`);
    
    return true;
  } catch (error) {
    logError(`Erreur d'authentification: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testProfilUtilisateur() {
  log('\nüë§ TEST PROFIL UTILISATEUR', 'cyan');
  log('============================', 'cyan');
  
  if (!authToken) {
    logWarning('Token d\'authentification requis');
    return false;
  }
  
  try {
    const headers = { Authorization: `Bearer ${authToken}` };
    
    // Test r√©cup√©ration profil
    logInfo('1. R√©cup√©ration du profil utilisateur...');
    const profileResponse = await axios.get(`${BASE_URL}/users/${currentUser._id}`, { headers });
    logSuccess(`Profil r√©cup√©r√©: ${profileResponse.data.user.username}`);
    
    // Test recherche utilisateurs
    logInfo('2. Test de recherche d\'utilisateurs...');
    const searchResponse = await axios.get(`${BASE_URL}/users/search?q=test`, { headers });
    logSuccess(`Recherche effectu√©e: ${searchResponse.data.users?.length || 0} r√©sultats`);
    
    // Test statistiques utilisateur
    logInfo('3. Test des statistiques utilisateur...');
    const statsResponse = await axios.get(`${BASE_URL}/users/${currentUser._id}/stats`, { headers });
    logSuccess('Statistiques r√©cup√©r√©es');
    
    return true;
  } catch (error) {
    logError(`Erreur profil utilisateur: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testGeolocalisation() {
  log('\nüó∫Ô∏è  TEST G√âOLOCALISATION', 'cyan');
  log('============================', 'cyan');
  
  try {
    // Test recherche √† proximit√© (public)
    logInfo('1. Test de recherche √† proximit√©...');
    const nearbyResponse = await axios.get(`${BASE_URL}/location/nearby?lat=9.5370&lng=-13.6785&radius=10`);
    logSuccess(`Recherche proximit√©: ${nearbyResponse.data.users?.length || 0} utilisateurs, ${nearbyResponse.data.events?.length || 0} √©v√©nements`);
    
    // Test mise √† jour position (authentifi√©)
    if (authToken) {
      logInfo('2. Test de mise √† jour de position...');
      const updateData = {
        latitude: 9.5370,
        longitude: -13.6785,
        address: 'Conakry, Guin√©e'
      };
      
      const updateResponse = await axios.post(`${BASE_URL}/location/update`, updateData, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Position mise √† jour');
    }
    
    // Test g√©ocodage
    logInfo('3. Test de g√©ocodage...');
    const geocodeResponse = await axios.get(`${BASE_URL}/location/geocode?address=Conakry, Guin√©e`);
    logSuccess('G√©ocodage r√©ussi');
    
    // Test r√©gions
    logInfo('4. Test des r√©gions de Guin√©e...');
    const regionsResponse = await axios.get(`${BASE_URL}/location/regions`);
    logSuccess(`R√©gions r√©cup√©r√©es: ${regionsResponse.data.regions?.length || 0} r√©gions`);
    
    return true;
  } catch (error) {
    logError(`Erreur g√©olocalisation: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testEvenements() {
  log('\nüéâ TEST √âV√âNEMENTS', 'cyan');
  log('============================', 'cyan');
  
  try {
    // Test calendrier (public)
    logInfo('1. Test du calendrier d\'√©v√©nements...');
    const calendarResponse = await axios.get(`${BASE_URL}/events/calendar`);
    logSuccess(`Calendrier r√©cup√©r√©: ${calendarResponse.data.events?.length || 0} √©v√©nements`);
    
    // Test recommandations (public)
    logInfo('2. Test des recommandations d\'√©v√©nements...');
    const recommendationsResponse = await axios.get(`${BASE_URL}/events/recommendations`);
    logSuccess(`Recommandations r√©cup√©r√©es: ${recommendationsResponse.data.events?.length || 0} √©v√©nements`);
    
    // Test cr√©ation d'√©v√©nement (authentifi√©)
    if (authToken) {
      logInfo('3. Test de cr√©ation d\'√©v√©nement...');
      const eventData = {
        title: 'Test Event ' + Date.now(),
        description: '√âv√©nement de test',
        date: new Date(Date.now() + 86400000).toISOString(), // Demain
        location: 'Conakry, Guin√©e',
        latitude: 9.5370,
        longitude: -13.6785
      };
      
      const createResponse = await axios.post(`${BASE_URL}/events`, eventData, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess(`√âv√©nement cr√©√©: ${createResponse.data.event.title}`);
      
      // Test participation
      logInfo('4. Test de participation √† l\'√©v√©nement...');
      const participateResponse = await axios.post(`${BASE_URL}/events/${createResponse.data.event._id}/participate`, {}, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Participation enregistr√©e');
    }
    
    return true;
  } catch (error) {
    logError(`Erreur √©v√©nements: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testModeration() {
  log('\nüõ°Ô∏è  TEST MOD√âRATION', 'cyan');
  log('============================', 'cyan');
  
  try {
    // Test signalement (authentifi√©)
    if (authToken) {
      logInfo('1. Test de signalement de contenu...');
      const reportData = {
        type: 'event',
        contentId: 'test-event-id',
        reason: 'Contenu inappropri√©',
        description: 'Test de signalement'
      };
      
      const reportResponse = await axios.post(`${BASE_URL}/moderation/report`, reportData, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Signalement enregistr√©');
    }
    
    // Test statistiques mod√©ration (public)
    logInfo('2. Test des statistiques de mod√©ration...');
    const statsResponse = await axios.get(`${BASE_URL}/moderation/stats`);
    logSuccess('Statistiques de mod√©ration r√©cup√©r√©es');
    
    // Test filtres automatiques (public)
    logInfo('3. Test des filtres automatiques...');
    const filtersResponse = await axios.get(`${BASE_URL}/moderation/filters`);
    logSuccess('Filtres automatiques r√©cup√©r√©s');
    
    return true;
  } catch (error) {
    logError(`Erreur mod√©ration: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testPerformance() {
  log('\n‚ö° TEST DE PERFORMANCE', 'cyan');
  log('============================', 'cyan');
  
  const endpoints = [
    { name: 'Profil utilisateur', url: '/users/test', method: 'GET' },
    { name: 'Recherche utilisateurs', url: '/users/search?q=test', method: 'GET' },
    { name: 'G√©olocalisation proximit√©', url: '/location/nearby?lat=9.5370&lng=-13.6785', method: 'GET' },
    { name: 'R√©gions', url: '/location/regions', method: 'GET' },
    { name: 'Calendrier √©v√©nements', url: '/events/calendar', method: 'GET' },
    { name: 'Recommandations √©v√©nements', url: '/events/recommendations', method: 'GET' }
  ];
  
  let successCount = 0;
  const startTime = Date.now();
  
  for (const endpoint of endpoints) {
    try {
      const start = Date.now();
      await axios.get(`${BASE_URL}${endpoint.url}`);
      const duration = Date.now() - start;
      
      logSuccess(`${endpoint.name}: ${duration}ms`);
      successCount++;
    } catch (error) {
      logError(`${endpoint.name}: √âchec`);
    }
  }
  
  const totalTime = Date.now() - startTime;
  const avgTime = totalTime / endpoints.length;
  
  log('\nüìä R√âSULTATS DE PERFORMANCE:', 'magenta');
  log(`‚úÖ Tests r√©ussis: ${successCount}/${endpoints.length}`, 'green');
  log(`‚è±Ô∏è  Temps total: ${totalTime}ms`, 'blue');
  log(`‚ö° Temps moyen: ${avgTime.toFixed(2)}ms`, 'blue');
  
  return successCount === endpoints.length;
}

// Menu principal
async function showMenu() {
  log('\nüéØ MENU DE TEST MANUEL - COMMUNICONNECT', 'magenta');
  log('==========================================', 'magenta');
  log('1. üîê Test d\'authentification', 'yellow');
  log('2. üë§ Test profil utilisateur', 'yellow');
  log('3. üó∫Ô∏è  Test g√©olocalisation', 'yellow');
  log('4. üéâ Test √©v√©nements', 'yellow');
  log('5. üõ°Ô∏è  Test mod√©ration', 'yellow');
  log('6. ‚ö° Test de performance', 'yellow');
  log('7. üß™ Test complet (tous les tests)', 'yellow');
  log('8. üìä Afficher les r√©sultats', 'yellow');
  log('9. üö™ Quitter', 'yellow');
  
  const choice = await question('\nChoisissez une option (1-9): ');
  
  switch (choice) {
    case '1':
      await testAuthentification();
      break;
    case '2':
      await testProfilUtilisateur();
      break;
    case '3':
      await testGeolocalisation();
      break;
    case '4':
      await testEvenements();
      break;
    case '5':
      await testModeration();
      break;
    case '6':
      await testPerformance();
      break;
    case '7':
      await runAllTests();
      break;
    case '8':
      showResults();
      break;
    case '9':
      log('üëã Au revoir !', 'green');
      rl.close();
      return;
    default:
      logError('Option invalide');
  }
  
  await question('\nAppuyez sur Entr√©e pour continuer...');
  await showMenu();
}

async function runAllTests() {
  log('\nüß™ LANCEMENT DE TOUS LES TESTS', 'magenta');
  log('================================', 'magenta');
  
  const tests = [
    { name: 'Authentification', fn: testAuthentification },
    { name: 'Profil Utilisateur', fn: testProfilUtilisateur },
    { name: 'G√©olocalisation', fn: testGeolocalisation },
    { name: '√âv√©nements', fn: testEvenements },
    { name: 'Mod√©ration', fn: testModeration },
    { name: 'Performance', fn: testPerformance }
  ];
  
  let successCount = 0;
  
  for (const test of tests) {
    logInfo(`\nüîç Test: ${test.name}`);
    try {
      const result = await test.fn();
      if (result) {
        logSuccess(`${test.name}: R√âUSSI`);
        successCount++;
      } else {
        logError(`${test.name}: √âCHEC`);
      }
    } catch (error) {
      logError(`${test.name}: ERREUR - ${error.message}`);
    }
  }
  
  log('\nüìä R√âSULTATS FINAUX:', 'magenta');
  log(`‚úÖ Tests r√©ussis: ${successCount}/${tests.length}`, 'green');
  log(`üìà Taux de succ√®s: ${((successCount / tests.length) * 100).toFixed(1)}%`, 'blue');
  
  if (successCount === tests.length) {
    log('üéâ TOUS LES TESTS SONT R√âUSSIS !', 'green');
  } else {
    log('‚ö†Ô∏è  Certains tests ont √©chou√©', 'yellow');
  }
}

function showResults() {
  log('\nüìä √âTAT ACTUEL', 'magenta');
  log('==============', 'magenta');
  log(`üîë Token d'authentification: ${authToken ? '‚úÖ Pr√©sent' : '‚ùå Absent'}`, authToken ? 'green' : 'red');
  log(`üë§ Utilisateur connect√©: ${currentUser ? currentUser.username : 'Aucun'}`, currentUser ? 'green' : 'red');
  log(`üåê URL de base: ${BASE_URL}`, 'blue');
}

function question(prompt) {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
}

// V√©rification de la connectivit√©
async function checkServer() {
  try {
    logInfo('V√©rification de la connectivit√© au serveur...');
    await axios.get(`${BASE_URL}/health`);
    logSuccess('Serveur accessible');
    return true;
  } catch (error) {
    logError('Serveur inaccessible. Assurez-vous que le serveur est d√©marr√© sur le port 5000.');
    return false;
  }
}

// Point d'entr√©e
async function main() {
  log('üß™ SCRIPT DE TEST MANUEL - COMMUNICONNECT', 'magenta');
  log('==========================================', 'magenta');
  log('Ce script permet de tester manuellement toutes les fonctionnalit√©s', 'blue');
  log('de CommuniConnect de mani√®re interactive.', 'blue');
  
  const serverOk = await checkServer();
  if (!serverOk) {
    logError('Impossible de continuer sans serveur accessible');
    process.exit(1);
  }
  
  await showMenu();
}

// Gestion des erreurs
process.on('unhandledRejection', (error) => {
  logError(`Erreur non g√©r√©e: ${error.message}`);
});

process.on('SIGINT', () => {
  log('\nüëã Arr√™t du script...', 'yellow');
  rl.close();
  process.exit(0);
});

// Lancement
if (require.main === module) {
  main().catch((error) => {
    logError(`Erreur fatale: ${error.message}`);
    process.exit(1);
  });
}

module.exports = {
  testAuthentification,
  testProfilUtilisateur,
  testGeolocalisation,
  testEvenements,
  testModeration,
  testPerformance
}; 