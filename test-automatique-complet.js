#!/usr/bin/env node

/**
 * üß™ SCRIPT DE TEST AUTOMATIQUE COMPLET - COMMUNICONNECT
 * 
 * Ce script ex√©cute automatiquement tous les tests sans interaction
 */

const axios = require('axios');

const BASE_URL = 'http://localhost:5000/api';
let authToken = null;
let currentUser = null;

// Couleurs pour l'affichage
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`‚úÖ ${message}`, 'green');
}

function logError(message) {
  log(`‚ùå ${message}`, 'red');
}

function logInfo(message) {
  log(`‚ÑπÔ∏è  ${message}`, 'blue');
}

function logWarning(message) {
  log(`‚ö†Ô∏è  ${message}`, 'yellow');
}

function logHeader(message) {
  log(`\n${message}`, 'magenta');
  log('='.repeat(message.length), 'magenta');
}

// Fonctions de test
async function testAuthentification() {
  logHeader('üîê TEST D\'AUTHENTIFICATION');
  
  try {
    // Test d'inscription
    logInfo('1. Test d\'inscription...');
    const registerData = {
      firstName: 'Test',
      lastName: 'User',
      email: `test${Date.now()}@communiconnect.com`,
      password: 'password123',
      phone: '22412345678',
      region: 'Conakry',
      prefecture: 'Conakry',
      commune: 'Kaloum',
      quartier: 'Centre',
      address: '123 Rue Test, Conakry',
      latitude: 9.5370,
      longitude: -13.6785
    };
    
    const registerResponse = await axios.post(`${BASE_URL}/auth/register`, registerData);
    logSuccess(`Inscription r√©ussie: ${registerData.username}`);
    
    // Test de connexion
    logInfo('2. Test de connexion...');
    const loginData = {
      identifier: registerData.email,
      password: registerData.password
    };
    
    const loginResponse = await axios.post(`${BASE_URL}/auth/login`, loginData);
    authToken = loginResponse.data.token;
    currentUser = loginResponse.data.user;
    
    logSuccess(`Connexion r√©ussie: ${currentUser.username}`);
    logInfo(`Token JWT re√ßu: ${authToken.substring(0, 20)}...`);
    
    return true;
  } catch (error) {
    logError(`Erreur d'authentification: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testProfilUtilisateur() {
  logHeader('üë§ TEST PROFIL UTILISATEUR');
  
  if (!authToken) {
    logWarning('Token d\'authentification requis');
    return false;
  }
  
  try {
    const headers = { Authorization: `Bearer ${authToken}` };
    
    // Test r√©cup√©ration profil
    logInfo('1. R√©cup√©ration du profil utilisateur...');
    const profileResponse = await axios.get(`${BASE_URL}/users/${currentUser._id}`, { headers });
    logSuccess(`Profil r√©cup√©r√©: ${profileResponse.data.user.username}`);
    
    // Test recherche utilisateurs
    logInfo('2. Test de recherche d\'utilisateurs...');
    const searchResponse = await axios.get(`${BASE_URL}/users/search?q=test`, { headers });
    logSuccess(`Recherche effectu√©e: ${searchResponse.data.users?.length || 0} r√©sultats`);
    
    // Test statistiques utilisateur
    logInfo('3. Test des statistiques utilisateur...');
    const statsResponse = await axios.get(`${BASE_URL}/users/${currentUser._id}/stats`, { headers });
    logSuccess('Statistiques r√©cup√©r√©es');
    
    return true;
  } catch (error) {
    logError(`Erreur profil utilisateur: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testGeolocalisation() {
  logHeader('üó∫Ô∏è  TEST G√âOLOCALISATION');
  
  try {
    // Test recherche √† proximit√© (public)
    logInfo('1. Test de recherche √† proximit√©...');
    const nearbyResponse = await axios.get(`${BASE_URL}/location/nearby?latitude=9.5370&longitude=-13.6785&radius=10`);
    logSuccess(`Recherche proximit√©: ${nearbyResponse.data.users?.length || 0} utilisateurs, ${nearbyResponse.data.events?.length || 0} √©v√©nements`);
    
    // Test mise √† jour position (authentifi√©)
    if (authToken) {
      logInfo('2. Test de mise √† jour de position...');
      const updateData = {
        latitude: 9.5370,
        longitude: -13.6785,
        address: 'Conakry, Guin√©e'
      };
      
      const updateResponse = await axios.post(`${BASE_URL}/location/update`, updateData, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Position mise √† jour');
    }
    
    // Test g√©ocodage
    logInfo('3. Test de g√©ocodage...');
    const geocodeResponse = await axios.get(`${BASE_URL}/location/geocode?address=Conakry, Guin√©e`);
    logSuccess('G√©ocodage r√©ussi');
    
    // Test r√©gions
    logInfo('4. Test des r√©gions de Guin√©e...');
    const regionsResponse = await axios.get(`${BASE_URL}/location/regions`);
    logSuccess(`R√©gions r√©cup√©r√©es: ${regionsResponse.data.regions?.length || 0} r√©gions`);
    
    return true;
  } catch (error) {
    logError(`Erreur g√©olocalisation: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testEvenements() {
  logHeader('üéâ TEST √âV√âNEMENTS');
  
  try {
    // Test calendrier (public)
    logInfo('1. Test du calendrier d\'√©v√©nements...');
    const calendarResponse = await axios.get(`${BASE_URL}/events/calendar`);
    logSuccess(`Calendrier r√©cup√©r√©: ${calendarResponse.data.events?.length || 0} √©v√©nements`);
    
    // Test recommandations (public)
    logInfo('2. Test des recommandations d\'√©v√©nements...');
    const recommendationsResponse = await axios.get(`${BASE_URL}/events/recommendations`);
    logSuccess(`Recommandations r√©cup√©r√©es: ${recommendationsResponse.data.events?.length || 0} √©v√©nements`);
    
          // Test cr√©ation d'√©v√©nement (authentifi√©)
      if (authToken) {
        logInfo('3. Test de cr√©ation d\'√©v√©nement...');
        const eventData = {
          title: 'Test Event ' + Date.now(),
          description: '√âv√©nement de test pour CommuniConnect',
          type: 'reunion',
          category: 'communautaire',
          startDate: new Date(Date.now() + 86400000).toISOString(), // Demain
          endDate: new Date(Date.now() + 86400000 + 7200000).toISOString(), // Demain + 2h
          startTime: '14:00',
          endTime: '16:00',
          venue: 'Centre Culturel Conakry',
          address: '123 Rue Test, Conakry, Guin√©e',
          latitude: 9.5370,
          longitude: -13.6785,
          capacity: 50,
          isFree: true,
          tags: ['test', 'communautaire']
        };
      
              const createResponse = await axios.post(`${BASE_URL}/events`, eventData, {
          headers: { Authorization: `Bearer ${authToken}` }
        });
        logSuccess(`√âv√©nement cr√©√©: ${createResponse.data.data.title}`);
      
              // Test participation
        logInfo('4. Test de participation √† l\'√©v√©nement...');
        const participateResponse = await axios.post(`${BASE_URL}/events/${createResponse.data.data._id}/participate`, {}, {
          headers: { Authorization: `Bearer ${authToken}` }
        });
      logSuccess('Participation enregistr√©e');
    }
    
    return true;
  } catch (error) {
    logError(`Erreur √©v√©nements: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testModeration() {
  logHeader('üõ°Ô∏è  TEST MOD√âRATION');
  
  try {
          // Test signalement (authentifi√©)
      if (authToken) {
        logInfo('1. Test de signalement de contenu...');
        const reportData = {
          targetType: 'event',
          targetId: 'test-event-id',
          reason: 'inappropriate',
          description: 'Test de signalement de contenu inappropri√©'
        };
      
      const reportResponse = await axios.post(`${BASE_URL}/moderation/report`, reportData, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Signalement enregistr√©');
    }
    
    // Test statistiques mod√©ration (authentifi√©)
    if (authToken) {
      logInfo('2. Test des statistiques de mod√©ration...');
      const statsResponse = await axios.get(`${BASE_URL}/moderation/stats`, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Statistiques de mod√©ration r√©cup√©r√©es');
    } else {
      logWarning('Token d\'authentification requis pour les statistiques de mod√©ration');
    }
    
    // Test filtres automatiques (authentifi√©)
    if (authToken) {
      logInfo('3. Test des filtres automatiques...');
      const filtersResponse = await axios.get(`${BASE_URL}/moderation/filters`, {
        headers: { Authorization: `Bearer ${authToken}` }
      });
      logSuccess('Filtres automatiques r√©cup√©r√©s');
    } else {
      logWarning('Token d\'authentification requis pour les filtres automatiques');
    }
    
    return true;
  } catch (error) {
    logError(`Erreur mod√©ration: ${error.response?.data?.message || error.message}`);
    return false;
  }
}

async function testPerformance() {
  logHeader('‚ö° TEST DE PERFORMANCE');
  
  const endpoints = [
    { name: 'Profil utilisateur', url: '/users/test', method: 'GET' },
    { name: 'Recherche utilisateurs', url: '/users/search?q=test', method: 'GET' },
    { name: 'G√©olocalisation proximit√©', url: '/location/nearby?latitude=9.5370&longitude=-13.6785', method: 'GET' },
    { name: 'R√©gions', url: '/location/regions', method: 'GET' },
    { name: 'Calendrier √©v√©nements', url: '/events/calendar', method: 'GET' },
    { name: 'Recommandations √©v√©nements', url: '/events/recommendations', method: 'GET' }
  ];
  
  let successCount = 0;
  const startTime = Date.now();
  
  for (const endpoint of endpoints) {
    try {
      const start = Date.now();
      await axios.get(`${BASE_URL}${endpoint.url}`);
      const duration = Date.now() - start;
      
      logSuccess(`${endpoint.name}: ${duration}ms`);
      successCount++;
    } catch (error) {
      logError(`${endpoint.name}: √âchec`);
    }
  }
  
  const totalTime = Date.now() - startTime;
  const avgTime = totalTime / endpoints.length;
  
  log('\nüìä R√âSULTATS DE PERFORMANCE:', 'magenta');
  log(`‚úÖ Tests r√©ussis: ${successCount}/${endpoints.length}`, 'green');
  log(`‚è±Ô∏è  Temps total: ${totalTime}ms`, 'blue');
  log(`‚ö° Temps moyen: ${avgTime.toFixed(2)}ms`, 'blue');
  
  return successCount === endpoints.length;
}

// V√©rification de la connectivit√©
async function checkServer() {
  try {
    logInfo('V√©rification de la connectivit√© au serveur...');
    await axios.get(`${BASE_URL}/health`);
    logSuccess('Serveur accessible');
    return true;
  } catch (error) {
    logError('Serveur inaccessible. Assurez-vous que le serveur est d√©marr√© sur le port 5000.');
    return false;
  }
}

// Ex√©cution de tous les tests
async function runAllTests() {
  logHeader('üß™ LANCEMENT DE TOUS LES TESTS AUTOMATIQUES');
  
  const tests = [
    { name: 'Authentification', fn: testAuthentification },
    { name: 'Profil Utilisateur', fn: testProfilUtilisateur },
    { name: 'G√©olocalisation', fn: testGeolocalisation },
    { name: '√âv√©nements', fn: testEvenements },
    { name: 'Mod√©ration', fn: testModeration },
    { name: 'Performance', fn: testPerformance }
  ];
  
  let successCount = 0;
  
  for (const test of tests) {
    logInfo(`\nüîç Test: ${test.name}`);
    try {
      const result = await test.fn();
      if (result) {
        logSuccess(`${test.name}: R√âUSSI`);
        successCount++;
      } else {
        logError(`${test.name}: √âCHEC`);
      }
    } catch (error) {
      logError(`${test.name}: ERREUR - ${error.message}`);
    }
  }
  
  logHeader('üìä R√âSULTATS FINAUX');
  log(`‚úÖ Tests r√©ussis: ${successCount}/${tests.length}`, 'green');
  log(`üìà Taux de succ√®s: ${((successCount / tests.length) * 100).toFixed(1)}%`, 'blue');
  
  if (successCount === tests.length) {
    log('üéâ TOUS LES TESTS SONT R√âUSSIS !', 'green');
  } else {
    log('‚ö†Ô∏è  Certains tests ont √©chou√©', 'yellow');
  }
  
  return successCount;
}

// Point d'entr√©e
async function main() {
  log('üß™ SCRIPT DE TEST AUTOMATIQUE COMPLET - COMMUNICONNECT', 'magenta');
  log('====================================================', 'magenta');
  log('Ce script ex√©cute automatiquement tous les tests sans interaction', 'blue');
  
  const serverOk = await checkServer();
  if (!serverOk) {
    logError('Impossible de continuer sans serveur accessible');
    process.exit(1);
  }
  
  const successCount = await runAllTests();
  
  logHeader('üéØ R√âSUM√â FINAL');
  log(`üìä Tests ex√©cut√©s: ${successCount}/6`, 'blue');
  log(`üöÄ Performance: ${successCount >= 4 ? 'EXCELLENTE' : successCount >= 2 ? 'BONNE' : '√Ä AM√âLIORER'}`, 'green');
  log(`üéâ CommuniConnect est ${successCount === 6 ? 'PR√äT POUR LA PRODUCTION' : 'EN D√âVELOPPEMENT'}`, 'magenta');
  
  process.exit(successCount === 6 ? 0 : 1);
}

// Gestion des erreurs
process.on('unhandledRejection', (error) => {
  logError(`Erreur non g√©r√©e: ${error.message}`);
  process.exit(1);
});

// Lancement
if (require.main === module) {
  main().catch((error) => {
    logError(`Erreur fatale: ${error.message}`);
    process.exit(1);
  });
}

module.exports = {
  testAuthentification,
  testProfilUtilisateur,
  testGeolocalisation,
  testEvenements,
  testModeration,
  testPerformance,
  runAllTests
}; 