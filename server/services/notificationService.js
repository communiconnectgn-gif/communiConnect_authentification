const io = require('socket.io');

class NotificationService {
  constructor(server) {
    this.io = io(server, {
      cors: {
        origin: process.env.CORS_ORIGIN || "http://localhost:3000",
        methods: ["GET", "POST"]
      }
    });
    
    this.connectedUsers = new Map(); // userId -> socketId
    this.userRooms = new Map(); // userId -> [room1, room2, ...]
    
    this.setupSocketHandlers();
  }

  setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log('üîî Nouvelle connexion notification:', socket.id);

      // Authentification de l'utilisateur
      socket.on('authenticate', (data) => {
        const { userId, token } = data;
        if (userId) {
          this.authenticateUser(socket, userId);
        }
      });

      // Rejoindre des rooms sp√©cifiques
      socket.on('join-rooms', (rooms) => {
        if (Array.isArray(rooms)) {
          rooms.forEach(room => {
            socket.join(room);
            console.log(`üë• Utilisateur ${socket.userId} a rejoint la room: ${room}`);
          });
        }
      });

      // Quitter des rooms
      socket.on('leave-rooms', (rooms) => {
        if (Array.isArray(rooms)) {
          rooms.forEach(room => {
            socket.leave(room);
            console.log(`üëã Utilisateur ${socket.userId} a quitt√© la room: ${room}`);
          });
        }
      });

      // Mettre √† jour la localisation pour les notifications g√©olocalis√©es
      socket.on('update-location', (location) => {
        if (socket.userId && location) {
          this.updateUserLocation(socket.userId, location);
        }
      });

      // Marquer une notification comme lue
      socket.on('mark-read', (notificationId) => {
        if (socket.userId) {
          this.markNotificationAsRead(socket.userId, notificationId);
        }
      });

      // Marquer toutes les notifications comme lues
      socket.on('mark-all-read', () => {
        if (socket.userId) {
          this.markAllNotificationsAsRead(socket.userId);
        }
      });

      // D√©connexion
      socket.on('disconnect', () => {
        console.log('üîî D√©connexion notification:', socket.id);
        if (socket.userId) {
          this.disconnectUser(socket.userId);
        }
      });
    });
  }

  authenticateUser(socket, userId) {
    socket.userId = userId;
    this.connectedUsers.set(userId, socket.id);
    
    // Rejoindre les rooms par d√©faut
    socket.join(`user:${userId}`);
    socket.join('global');
    
    console.log(`‚úÖ Utilisateur ${userId} authentifi√© pour les notifications`);
    
    // Envoyer les notifications non lues
    this.sendUnreadNotifications(userId);
  }

  disconnectUser(userId) {
    this.connectedUsers.delete(userId);
    console.log(`üîå Utilisateur ${userId} d√©connect√© des notifications`);
  }

  updateUserLocation(userId, location) {
    // Mettre √† jour la localisation pour les notifications g√©olocalis√©es
    console.log(`üìç Localisation mise √† jour pour l'utilisateur ${userId}:`, location);
  }

  // Envoyer une notification √† un utilisateur sp√©cifique
  sendToUser(userId, notification) {
    const socketId = this.connectedUsers.get(userId);
    if (socketId) {
      this.io.to(socketId).emit('notification', notification);
      console.log(`üì® Notification envoy√©e √† l'utilisateur ${userId}:`, notification.type);
    }
  }

  // Envoyer une notification √† plusieurs utilisateurs
  sendToUsers(userIds, notification) {
    userIds.forEach(userId => {
      this.sendToUser(userId, notification);
    });
  }

  // Envoyer une notification √† une room
  sendToRoom(room, notification) {
    this.io.to(room).emit('notification', notification);
    console.log(`üì¢ Notification envoy√©e √† la room ${room}:`, notification.type);
  }

  // Envoyer une notification globale
  sendGlobal(notification) {
    this.io.to('global').emit('notification', notification);
    console.log(`üåç Notification globale envoy√©e:`, notification.type);
  }

  // Envoyer une notification g√©olocalis√©e
  sendGeolocated(notification, radius = 10) {
    // TODO: Impl√©menter la logique de g√©olocalisation
    // Pour l'instant, on envoie √† tous les utilisateurs connect√©s
    this.io.to('global').emit('notification', notification);
    console.log(`üó∫Ô∏è Notification g√©olocalis√©e envoy√©e:`, notification.type);
  }

  // Notifications sp√©cifiques par type
  sendNewPostNotification(post, author) {
    const notification = {
      id: Date.now().toString(),
      type: 'new_post',
      title: 'Nouvelle publication',
      message: `${author.firstName} ${author.lastName} a publi√© quelque chose`,
      data: {
        postId: post._id,
        authorId: author._id,
        authorName: `${author.firstName} ${author.lastName}`,
        postType: post.type,
        location: post.location
      },
      timestamp: new Date(),
      read: false,
      priority: 'normal'
    };

    // Envoyer aux utilisateurs de la m√™me r√©gion/quartier
    this.sendToRoom(`region:${post.location.region}`, notification);
  }

  sendNewAlertNotification(alert, author) {
    const notification = {
      id: Date.now().toString(),
      type: 'new_alert',
      title: 'Nouvelle alerte',
      message: `Alerte ${alert.type} dans votre zone`,
      data: {
        alertId: alert._id,
        authorId: author._id,
        alertType: alert.type,
        priority: alert.priority,
        location: alert.location
      },
      timestamp: new Date(),
      read: false,
      priority: alert.priority === 'urgent' ? 'high' : 'normal'
    };

    // Envoyer aux utilisateurs de la m√™me zone
    this.sendGeolocated(notification, alert.impactRadius || 5);
  }

  sendNewEventNotification(event, organizer) {
    const notification = {
      id: Date.now().toString(),
      type: 'new_event',
      title: 'Nouvel √©v√©nement',
      message: `${organizer.firstName} ${organizer.lastName} organise un √©v√©nement`,
      data: {
        eventId: event._id,
        organizerId: organizer._id,
        organizerName: `${organizer.firstName} ${organizer.lastName}`,
        eventTitle: event.title,
        eventDate: event.startDate,
        location: event.location
      },
      timestamp: new Date(),
      read: false,
      priority: 'normal'
    };

    // Envoyer aux utilisateurs de la m√™me r√©gion
    this.sendToRoom(`region:${event.location.region}`, notification);
  }

  sendHelpRequestNotification(request, author) {
    const notification = {
      id: Date.now().toString(),
      type: 'help_request',
      title: 'Demande d\'aide',
      message: `${author.firstName} ${author.lastName} a besoin d'aide`,
      data: {
        requestId: request._id,
        authorId: author._id,
        authorName: `${author.firstName} ${author.lastName}`,
        category: request.category,
        priority: request.priority,
        location: request.location
      },
      timestamp: new Date(),
      read: false,
      priority: request.priority === 'urgent' ? 'high' : 'normal'
    };

    // Envoyer aux utilisateurs de la m√™me zone
    this.sendGeolocated(notification, 5);
  }

  sendCommentNotification(comment, post, commenter) {
    const notification = {
      id: Date.now().toString(),
      type: 'new_comment',
      title: 'Nouveau commentaire',
      message: `${commenter.firstName} ${commenter.lastName} a comment√© votre publication`,
      data: {
        commentId: comment._id,
        postId: post._id,
        commenterId: commenter._id,
        commenterName: `${commenter.firstName} ${commenter.lastName}`,
        commentContent: comment.content.substring(0, 100)
      },
      timestamp: new Date(),
      read: false,
      priority: 'normal'
    };

    // Envoyer √† l'auteur du post
    this.sendToUser(post.author, notification);
  }

  sendLikeNotification(like, post, liker) {
    const notification = {
      id: Date.now().toString(),
      type: 'new_like',
      title: 'Nouveau j\'aime',
      message: `${liker.firstName} ${liker.lastName} a aim√© votre publication`,
      data: {
        likeId: like._id,
        postId: post._id,
        likerId: liker._id,
        likerName: `${liker.firstName} ${liker.lastName}`
      },
      timestamp: new Date(),
      read: false,
      priority: 'low'
    };

    // Envoyer √† l'auteur du post
    this.sendToUser(post.author, notification);
  }

  sendEventReminderNotification(event, participants) {
    const notification = {
      id: Date.now().toString(),
      type: 'event_reminder',
      title: 'Rappel d\'√©v√©nement',
      message: `L'√©v√©nement "${event.title}" commence dans 1 heure`,
      data: {
        eventId: event._id,
        eventTitle: event.title,
        eventDate: event.startDate,
        location: event.location
      },
      timestamp: new Date(),
      read: false,
      priority: 'normal'
    };

    // Envoyer aux participants
    participants.forEach(participant => {
      this.sendToUser(participant.user, notification);
    });
  }

  sendModerationNotification(userId, action, reason) {
    const notification = {
      id: Date.now().toString(),
      type: 'moderation',
      title: 'Action de mod√©ration',
      message: `Votre compte a √©t√© ${action}`,
      data: {
        action,
        reason,
        timestamp: new Date()
      },
      timestamp: new Date(),
      read: false,
      priority: 'high'
    };

    this.sendToUser(userId, notification);
  }

  sendSystemNotification(userId, title, message, data = {}) {
    const notification = {
      id: Date.now().toString(),
      type: 'system',
      title,
      message,
      data,
      timestamp: new Date(),
      read: false,
      priority: 'normal'
    };

    this.sendToUser(userId, notification);
  }

  // Marquer une notification comme lue
  async markNotificationAsRead(userId, notificationId) {
    // TODO: Impl√©menter la logique de base de donn√©es
    console.log(`‚úÖ Notification ${notificationId} marqu√©e comme lue pour l'utilisateur ${userId}`);
  }

  // Marquer toutes les notifications comme lues
  async markAllNotificationsAsRead(userId) {
    // TODO: Impl√©menter la logique de base de donn√©es
    console.log(`‚úÖ Toutes les notifications marqu√©es comme lues pour l'utilisateur ${userId}`);
  }

  // Envoyer les notifications non lues
  async sendUnreadNotifications(userId) {
    // TODO: R√©cup√©rer les notifications non lues depuis la base de donn√©es
    const unreadNotifications = [];
    
    if (unreadNotifications.length > 0) {
      this.sendToUser(userId, {
        type: 'unread_notifications',
        data: unreadNotifications
      });
    }
  }

  // Obtenir les statistiques des connexions
  getStats() {
    return {
      connectedUsers: this.connectedUsers.size,
      totalRooms: this.io.sockets.adapter.rooms.size,
      activeConnections: this.io.engine.clientsCount
    };
  }

  // Broadcast des statistiques
  broadcastStats() {
    const stats = this.getStats();
    this.io.emit('server_stats', stats);
  }
}

module.exports = NotificationService; 